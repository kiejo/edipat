//form generators

(defn gen_root { t: "List" els: [(gen_pending)] active: "t" sel_el: 0 } )

(defn gen_pending { t: "pending" })


//helper methods

(defn activate node (merge node { active: "t" }))

(defn deactivate node (merge node { active: "f" }))

(defn is_active el
	(== (#active el) "t"))

(defn activate_nth n els (match [n els]
	([0 []]          [])
	([0 [el & rest]] (cons (activate el) rest))
	([i [el & rest]] (cons el (activate_nth (dec i) rest)))))

(defn remove_nth n els (match [n els]
	([0 []]          [])
	([0 [el & rest]] rest)
	([i [el & rest]] (cons el (remove_nth (dec i) rest)))))

(defn deactivate_all els
	(map (merge _ { active: "f" }) els))

(defn like_list el (any (== el _) ["List" "Arr" "Obj" "Pair"]))

(defn contains_active_elem els (any is_active els))

(defn contains_active_type type els
	(any (fn el (&& (== (#t el) type) (is_active el))) els))

(defn get_triggered_input node input
	(match [input node]
		([" " {t: "List" active: "t" els: (contains_active_type "Atom" _)}] ["uarr" " "])
		([" " {t: "List" active: "t" els: (contains_active_type "Num" _)}]  ["uarr" " "])
		(["'" {t: "List" active: "t" els: (contains_active_type "Str" _)}]  ["uarr" " "])

		(["del" {t: "List" active: "t" els: (contains_active_type "Atom" _)}] ["uarr" "del" "darr"])

		(_ [input])
))

(defn update_node node input
	(merge node (match node

		({t: (like_list) active: "t" els: (contains_active_elem) sel_el: el_ind}
			{ els: (map (update_node _ input) (#els node)) })

		({t: (like_list) active: "t" els: elems sel_el: el_ind}
			(match input
				("larr" { sel_el: (dec el_ind) })
				("rarr" { sel_el: (inc el_ind) })
				("uarr" { active: "f" })
				("darr" { els: (activate_nth el_ind elems) })
				("del"  { els: (remove_nth   el_ind elems) sel_el: (if (== (#length elems) (inc el_ind)) (dec el_ind) el_ind) })
				(" "    { els: (concat (deactivate_all elems) (activate (gen_pending))) sel_el: (inc el_ind) })
				(_  {})))

		({t: "pending" active: "t"}
			(match input
				("'"       { t: "Str"  val: "" })
				("["       { t: "Arr"  els: [(activate (gen_pending))] sel_el: 0 })
				("("       { t: "List" els: [(activate (gen_pending))] sel_el: 0 })
				("{"       { t: "Obj"  els: [(activate (gen_pending))] sel_el: 0 })
				(":"       { t: "Pair" els: [(activate { t: "Atom" val: "" }) (gen_pending)] sel_el: 0 })
				((is_num)  { t: "Num"  val: input })
				((is_atom) { t: "Atom" val: input })))

		({t: "Str" active: "t" val: value}
			(match input
				("uarr" { active: "f" })
				("'"    { active: "f" })
				("bs"   { val: (init value) })
				(c      { val: (+ value c) })))

		({t: "Num" active: "t" val: value}
			(match input
				("uarr"   { active: "f" })
				("bs"     { val: (init value) })
				((is_num) { val: (+ value input) })))

		({t: "Atom" active: "t" val: value}
			(match input
				("uarr"    { active: "f" })
				("bs"      { val: (init value) })
				((is_atom) { val: (+ value input) })))

		(_ {})
	))
)

(defn update_node_multi node keycodes
	(foldl node update_node keycodes))

//renderer

(defn render node (match node
	({t: "List" els: elems sel_el: sel_ind active: act}
		(str ["(" (join " " (map render elems)) ")"]))

	({t: "Arr" els: elems sel_el: sel_ind}
		(str ["[" (join " " (map render elems)) "]"]))

	({t: "Obj" els: elems sel_el: sel_ind}
		(str ["{ " (join " " (map render elems)) " }"]))

	({t: "Pair" els: [k v]} (str [(render k) ": " (render v)]))

	({t: "Num" val: value  active: act} (render_active value act))

	({t: "Str" val: value  active: act} (str ["'" (render_active value act) "'"]))

	({t: "Atom" val: value  active: act} (render_active value act))

	({t: "pending" active: act} (render_active "..." act))

))

(defn render_active s is_active
	(if (== is_active "t")
		(wrap_span s "active")
		s))

(defn wrap_span cont cl (str ["<span class='" cl "'>" cont "</span>"]))


//view and user interaction

(def root_node (gen_root))

(defn update_view node (do
	(.text ($ "#ast") (.parse jsDump node))
	(.html ($ "#rendered") (render node)))
)

(defn update node input (do
	(set root_node (update_node_multi node (get_triggered_input node input)))
	(update_view root_node)
))


//input handling

(def special_input [
	[8  "bs"]
	[37 "larr"]
	[38 "uarr"]
	[39 "rarr"]
	[40 "darr"]
	[46 "del"]
])

(defn is_num input (any (== input _) (map (fn n (.toString n)) (range 0 9))))

(defn is_atom input (! (any (fn pair (match pair ([_ s] (== s input)))) special_input)))


//make sure input only triggers one of the two possible events and normalize keycode to string/char

(defn handle_keydown handler key_event
	(match (kd_keycode_to_s special_input (#which key_event))
		("not_matched" undefined)
		(s (handler s))))

(defn kd_keycode_to_s pairs kc
	(match (find (fn pair (match pair ([code s] (== code kc)))) pairs)
		("undefined" "not_matched")
		([_ s] s)
))

(defn handle_keypress handler key_event
	(handler (.fromCharCode String (#which key_event))))

(.ready ($ document) (fn (do

	(update root_node "darr") //activate first child

	(.keydown  ($ "#input") (handle_keydown  (update root_node _) _))
	(.keypress ($ "#input") (handle_keypress (update root_node _) _))

)))