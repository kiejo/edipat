(defn gen_atom_name { t: "atom" name: "" active: "t" })

(defn gen_arg
	{ t: "arg" expr: {} })

(defn gen_def_var 
	{ t: "def_var" name: (gen_atom_name) body: {} })

(defn gen_def_fn 
	{ t: "def_fn" name: (gen_atom_name) args: [] body: {} })

(defn gen_call_fn
	{ t: "call_fn" name: (gen_atom_name) args: [ (gen_arg) ] active: "f" })

(defn gen_body t (match t
	("def_var" { t: "" active: "t"})
	("call_fn" {})))

(defn to_char keycode (.fromCharCode String keycode))

(defn activate ast (merge ast { active: "t" }))

(defn deactivate ast (merge ast { active: "f" }))

(defn gen_space type ast
	(merge
		(merge ast { name: { active: "f" } })
		(match type
			("def_var" { body: { active: "t" } })
			
			("def_fn"  (match ast
				({ args: [ first & rest ] } { args: (cons (activate first) rest) })))

			("call_fn" (match ast
				({ args: [ first & rest ] } { args: (cons (activate first) rest) })))

			)))



(defn update_ast ast keycode
	(match ast

		({ t: "program" active: "t" els: elements }
			(match keycode 
				(65 (merge ast { active: "f" els: (cons (gen_def_var) elements) }))))

		({ t: "program" els: elements }
			(match keycode
				
				(_ (merge ast {active: "f" els: (map (fn el (update_ast el keycode)) elements)}))))



		({ t: type name: { t: "atom" name: name active: "t" } }
		 (match keycode
		 	(8 (if (== (#length name) 1)
		 		   {}
		 		   (merge ast { name: { name: (init name) } })))
		 	(32 (merge ast (gen_space type ast)))
		 	(kc (merge ast { name: { name: (+ name (to_char kc)) } }))))

		({ t: "arg" expr: { t: "atom" name: name active: "t" } }
		 (match keycode
		 	(8 (if (== (#length name) 1)
		 		   []
		 		   (merge ast { expr: { name: (init name) } })))
		 	(32 [(merge ast { expr: { active: "f" } }), (activate (gen_arg))])
		 	(kc (merge ast { expr: { name: (+ name (to_char kc)) } }))))


		({ t: type body: { active: "t" } }
		 (match keycode
		 	(65 (merge ast { body: (gen_call_fn) }))
		 	))

		({ t: type body: body }
			(merge ast { body: (update_ast body keycode) }))


		({ t: "call_fn" args: args }
			(merge ast { args: (flatten (map (fn arg (process_arg arg keycode)) args)) }))

		(_ ast)))


(defn process_arg arg keycode (match arg
	
	({ t: "arg" active: "t" }
	 (match keycode 
		(65 (merge (deactivate arg) { expr: (gen_atom_name) }))
		))

	({ t: "arg" expr: { t: _ } } (update_ast arg keycode))

	))

(defn update_view ast
	(.text ($ "#ast") (.parse jsDump ast)))


(.ready ($ document) (fn (

	(def ast { t: "program" els: [] active: "t" })
	(update_view ast)

	(.keyup ($ "#input") (fn e (
		(set ast (update_ast ast (#which e)))
		(update_view ast)
		)))

)))