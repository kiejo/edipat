//form generators

(defn gen_root (gen_type_with_els "root" [(gen_pending "...")]))

(defn gen_type_with_val type value { t: type val: value state: "n" active: "f" })
(def gen_pending (gen_type_with_val "pending" _))
(def gen_atom    (gen_type_with_val "Atom" _))
(def gen_num     (gen_type_with_val "Num" _))
(def gen_str     (gen_type_with_val "Str" _))

(defn gen_type_with_els type els { t: type els: els sel_el: 0 state: "n" active: "f" })
(def gen_list (gen_type_with_els "List" _))
(def gen_arr  (gen_type_with_els "Arr" _))
(def gen_obj  (gen_type_with_els "Obj" _))
(def gen_pair (gen_type_with_els "Pair" _))

//helper methods

(defn activate node (merge node { active: "t" }))

(defn deactivate node (merge node { active: "f" }))

(defn is_active el
	(== (#active el) "t"))

(defn activate_nth n els (match [n els]
	([0 []]          [])
	([0 [el & rest]] (cons (activate el) rest))
	([i [el & rest]] (cons el (activate_nth (dec i) rest)))))

(defn remove_nth n els (match [n els]
	([0 []]          [])
	([0 [el & rest]] rest)
	([i [el & rest]] (cons el (remove_nth (dec i) rest)))))

(defn deactivate_all els
	(map (merge _ { active: "f" }) els))

(defn like_list el (any (== el _) ["root" "List" "Arr" "Obj" "Pair"]))

(defn non_active els
	(all (fn el (! (is_active el))) els))

(defn contains_active_elem els (any is_active els))

(defn is_type types el (any (== (#t el) _) types))

(defn is_active_type types el (&& (is_active el) (is_type types el)))

(defn contains_active_type types els
	(any (is_active_type types _) els))

(defn is_real_active el (match el
	((is_active_type ["Atom" "Num" "Str" "pending"] _) true)
	({active: "t" t: (like_list _) els: (non_active)} true)
	(_ false)))

(defn contains_real_active els
	(any (is_real_active _) els))

(defn get_triggered_input node input
	(match [input node]

		([" " {t: "Pair" active: "t" els: [ (is_active_type ["Atom"] _) _ ]}] ["uarr" "rarr" "darr"])
		([" " {t: "Pair" active: "t" els: [ _ (is_real_active _)     ]}]      ["uarr" "uarr" " " ":"])

		([")" {t: "List" active: "t" els: (contains_real_active _)}] ["uarr" "uarr" " "])

		([" " {t: (like_list) active: "t" els: (contains_active_type ["Atom" "Num"] _)}] ["uarr" " "])
		(["'" {t: (like_list) active: "t" els: (contains_active_type ["Str"] _)}]        ["uarr" " "])

		(["larr" {t: (like_list) active: "t" els: (contains_active_type ["Atom" "Num" "Str" "pending" "List"] _)}] ["uarr" "larr" "darr"])
		(["rarr" {t: (like_list) active: "t" els: (contains_active_type ["Atom" "Num" "Str" "pending" "List"] _)}] ["uarr" "rarr" "darr"])
		(["del"  {t: (like_list) active: "t" els: (contains_active_type ["Atom" "Num" "Str" "pending" "List"] _)}] ["uarr" "del"  "darr"])

		([_ {t: (like_list) active: "t" els: (contains_active_elem) sel_el: el_ind}]
			(get_triggered_input (nth el_ind (#els node)) input))

		(_ [input])
))

(defn update_node node input
	(merge node (match node

		({t: (like_list) active: "t" els: (contains_active_elem) sel_el: el_ind}
			{ els: (map (update_node _ input) (#els node)) })

		({t: (like_list) active: "t" els: elems sel_el: el_ind}
			(match input
				("larr" { sel_el: (mod (dec el_ind) (#length (#els node))) })
				("rarr" { sel_el: (mod (inc el_ind) (#length (#els node))) })
				("uarr" (if (== (#t node) "root") {} { active: "f" }))
				("darr" { els: (activate_nth el_ind elems) })
				("del"  { els: (remove_nth   el_ind elems) sel_el: (if (== (#length elems) (inc el_ind)) (dec el_ind) el_ind) })
				(" "    { els: (insert_at (inc el_ind) (activate (gen_pending "...")) (deactivate_all elems)) sel_el: (inc el_ind) })
				(_  {})))

		({t: "pending" active: "t"}
			(match input
				("uarr"    { active: "f" })
				("'"       (activate (gen_str "")))
				("["       (activate (gen_arr  [(activate (gen_pending "el"))])))
				("("       (activate (gen_list [(activate (gen_pending "el"))])))
				("{"       (activate (gen_obj  [(activate (gen_pair [(activate (gen_atom "key")) (gen_pending "el")]))])))
				(":"       (activate (gen_pair [(activate (gen_atom "key")) (gen_pending "el")])))
				((is_num)  (activate (gen_num input)))
				((is_atom) (activate (gen_atom input)))))

		({t: "Str" active: "t" val: value}
			(match input
				("uarr" { active: "f" })
				("'"    { active: "f" })
				("bs"   { val: (init value) })
				(c      { val: (+ value c) })))

		({t: "Num" active: "t" val: value}
			(match input
				("uarr"   { active: "f" })
				("bs"     { val: (init value) })
				((is_num) { val: (+ value input) })))

		({t: "Atom" active: "t" state: "pending"}
			(match input
				("uarr"    { active: "f" })
				((is_atom) { val: input state: "n"})))

		({t: "Atom" active: "t" val: value}
			(match input
				("uarr"    { active: "f" })
				("bs"      { val: (init value) })
				((is_atom) { val: (+ value input) })))

		(_ {})
	))
)

(defn update_node_multi node keycodes
	(foldl node update_node keycodes))

(defn make_state_pending el
	(merge el (match el
		({els: elems} { state: "pending" els: (map (make_state_pending _) elems) })
		({}           { state: "pending" }))))

(defn is_state_pending el (== (#state el) "pending"))

(defn post_triggers node completions
	(merge node (match node
		({t: "List" active: "t" els: [ { t: "Atom" val: fn_name active: "t" } & (all (is_state_pending _) _) ]}
			(match (get_form fn_name completions)
				({gen: items} { els: (cons (head (#els node)) (map (make_state_pending _) items)) })
				(_            { els: [(head (#els node))] })))

		({t: (like_list) active: "t" els: elems}
			{ els: (map (post_triggers _ completions) elems) })

		(_ {})
	))
)

(defn get_completions node root (match node
	({t: "List" active: "t" els: [ { t: "Atom" val: fn_name active: "t" } & rest ]}
		(filter (fn form (starts_with fn_name (#name form))) (concat special_forms (get_fns_in_scope root))))

	({t: (like_list) active: "t" els: elems}
		(flatten (map (get_completions _ root) elems)))

	(_ [])
))

(defn take_with_fst_active els (match els
	([] [])
	([{active: "t"} & rest] [(head els)])
	([el & rest] (cons el (take_with_fst_active rest)))))

(defn get_fns_in_scope node
	(match node
		({t: "root" els: elems}
			(flatten (map get_fns_in_scope elems)))

		({t: "List" active: "t" els: [{t: "Atom" val: "do"} & rest]}
			(flatten (map get_fns_in_scope (take_with_fst_active rest))))

		({t: "List" els: [{t: "Atom" val: "defn"} {t: "Atom" val: name state: "n"} & rest]}
			[{name: name gen: (map (fn arg (gen_pending (#val arg))) (init rest))}])

		(_ [])
	)
)

//special forms
(def special_forms [
	{ name: "def"  gen: [ (gen_atom "name") (gen_pending "value") ] }
	{ name: "set"  gen: [ (gen_atom "name") (gen_pending "value") ] }
	{ name: "defn" gen: [ (gen_atom "name") (gen_atom "arg1") (gen_pending "body") ] }
	{ name: "fn"   gen: [ (gen_atom "arg1")  (gen_pending "body") ] }
	{ name: "if"   gen: [ (gen_pending "cond") (gen_pending "else") (gen_pending "else") ] }
	{ name: "nth"  gen: [ (gen_pending "index") (gen_pending "array") ] }
	{ name: "do"   gen: [ (gen_list [(gen_pending "...")]) ] }

	{ name: "match" gen: [ (gen_pending "value") (gen_list [(gen_pending "patt") (gen_pending "expr")]) ] }
])

(defn get_form name forms
	(find (fn form (== (#name form) name)) forms))


//renderer

(defn gen_active_class node
	(str ["active_" (is_real_active node)]))

(defn prepare_render node
	(merge node (match node

		({t: (like_list) els: elems}
			{ classes: [(gen_active_class node)] els: (map prepare_node elems) })

		(_ { classes: [(gen_active_class node)] })
	))
)

(defn render node (match node

	({t: "root" els: elems}
		(join "<br/>" (map render elems)))

	({t: "List" active: "t" els: (non_active)}
		(wrap_span (str ["(" (join " " (map render (#els node))) ")"]) "act_t"))

	({t: "List" els: elems}
		(str ["(" (join " " (map render elems)) ")"]))

	({t: "Arr" els: elems}
		(str ["[" (join " " (map render elems)) "]"]))

	({t: "Obj" els: elems}
		(str ["{ " (join " " (map render elems)) " }"]))

	({t: "Str" } (str ["'" (render_primitive node) "'"]))

	({t: "Pair" els: [k v]} (str [(render k) ": " (render v)]))

	(el (render_primitive el))
))

(defn get_classes prim (match prim
	({t: type, active: act state: st} [(str ["type_" type]) (str ["act_" act]) (str ["st_" st])])
	(_ [])))

(defn render_primitive prim
	(wrap_span (#val prim) (join " " (get_classes prim))))

(defn wrap_span cont cl (str ["<span class='" cl "'>" cont "</span>"]))


//view and user interaction

(def root_node (activate (gen_root)))

(def completion_helper [])

(defn update_view node (do
	(.text ($ "#ast") (.parse jsDump node))
	(.html ($ "#rendered") (render node))
))

(defn update_view_compl completions (do
	(.html ($ "#completions") (join ", " (map (fn el (#name el)) completions)))
))

(defn update node input (do
	(def tmp_node (update_node_multi node (get_triggered_input node input)))
	(set completion_helper (get_completions tmp_node tmp_node))

	(set root_node (post_triggers tmp_node completion_helper))

	(update_view root_node)
	(update_view_compl completion_helper)
))


//input handling

(def special_input [
	[8  "bs"]
	[37 "larr"]
	[38 "uarr"]
	[39 "rarr"]
	[9  "tab"]
	[40 "darr"]
	[46 "del"]
])

(defn is_num input (any (== input _) (map (fn n (.toString n)) (range 0 9))))

(defn is_atom input (! (any (fn pair (match pair ([_ s] (== s input)))) special_input)))


//make sure input only triggers one of the two possible events and normalize keycode to string/char

(defn handle_keydown handler key_event
	(match (kd_keycode_to_s special_input (#which key_event))
		("not_matched" undefined)
		(s (handler s))))

(defn kd_keycode_to_s pairs kc
	(match (find (fn pair (match pair ([code s] (== code kc)))) pairs)
		([_ s] s)
		(_     "not_matched")
))

(defn handle_keypress handler key_event
	(handler (.fromCharCode String (#which key_event))))

(.ready ($ document) (fn (do

	(update root_node "darr") //activate first child

	(.keydown  ($ "#input") (handle_keydown  (update root_node _) _))
	(.keypress ($ "#input") (handle_keypress (update root_node _) _))

)))